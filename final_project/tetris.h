#ifndef _TETRIS_H_
#define _TETRIS_H_

#include <ncurses.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define WIDTH 10         // 테트리스 필드의 가로 크기
#define HEIGHT 22        // 테트리스 필드의 세로 크기
#define NOTHING 0
#define QUIT 'q'
#define NUM_OF_SHAPE 7
#define NUM_OF_ROTATE 4
#define BLOCK_HEIGHT 4
#define BLOCK_WIDTH 4
#define BLOCK_NUM 3
#define BEAM_WIDTH 3 // 각 레벨에서 고려할 자식 노드 수

// menu number
#define MENU_PLAY '1'
#define MENU_RANK '2'
#define MENU_RECOMMENDED_PLAY '3'
#define MENU_EXIT '4'

// 사용자 이름의 길이
#define NAMELEN 16
// 추천 트리의 최대 자식 노드 수
#define CHILDREN_MAX 36

typedef struct _RecNode {
  // 추천 트리의 level(or depth)
  int level;
  // 누적된 점수             
  int accumulatedScore;
  // 추천된 블록의 위치와 회전 수를 고려해서 놓을 때 필드 상태  
  char recField[HEIGHT][WIDTH];
  // tree에서 children 노드들을 가리키는 포인터 배열, child 수만큼 동적 할당
  struct _RecNode **child;
  // 블록 위치 정보
  int blockX;
  int blockY;
  int blockRotate;
} RecNode;

typedef struct Node {
  char name[NAMELEN];
  int score;
  struct Node* next;
} Node;

/* [blockShapeID][# of rotate][][] */
const char block[NUM_OF_SHAPE][NUM_OF_ROTATE][BLOCK_HEIGHT][BLOCK_WIDTH] = {
    { /*[0][][][]					▩▩▩▩*/
     {/*[][0][][]*/
      {0, 0, 0, 0},
      {1, 1, 1, 1},
      {0, 0, 0, 0},
      {0, 0, 0, 0}},
     {/*[][1][][]*/
      {0, 1, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 0, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {1, 1, 1, 1},
      {0, 0, 0, 0},
      {0, 0, 0, 0}},
     {/*[][3][][]*/
      {0, 1, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 0, 0}}},
    { /*[1][][][];					  ▩▩▩*/
     {/*[][0][][]				        ▩*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 1},
      {0, 0, 0, 1}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 1},
      {0, 0, 1, 0},
      {0, 0, 1, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 1, 1},
      {0, 0, 0, 0}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 0},
      {0, 0, 1, 0},
      {0, 1, 1, 0}}},
    { /*[2][][][];					  ▩▩▩*/
     {/*[][0][][]				      ▩*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 1},
      {0, 1, 0, 0}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 0},
      {0, 0, 1, 0},
      {0, 0, 1, 1}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 1},
      {0, 1, 1, 1},
      {0, 0, 0, 0}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 0, 1, 0},
      {0, 0, 1, 0}}},
    { /*[3][][][];					  ▩▩▩*/
     {/*[][0][][]				    ▩*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {1, 1, 1, 0},
      {0, 0, 0, 0}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {1, 1, 0, 0},
      {0, 1, 0, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {1, 1, 1, 0},
      {0, 1, 0, 0}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 1, 0},
      {0, 1, 0, 0}}},
    { /*[4][][][];					  ▩▩*/
     {/*[][0][][]				      ▩▩*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 1, 1, 0}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 1, 1, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 1, 1, 0}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 1, 1, 0}}},
    { /*[5][][][];					  ▩▩*/
     {/*[][0][][]				▩▩*/
      {0, 0, 0, 0},
      {0, 0, 1, 1},
      {0, 1, 1, 0},
      {0, 0, 0, 0}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 1, 0},
      {0, 0, 1, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 1},
      {0, 1, 1, 0},
      {0, 0, 0, 0}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 1, 0, 0},
      {0, 1, 1, 0},
      {0, 0, 1, 0}}},
    { /*[6][][][];					▩▩*/
     {/*[][0][][]				  ▩▩*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 0, 1, 1}},
     {/*[][1][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 0},
      {0, 1, 1, 0},
      {0, 1, 0, 0}},
     {/*[][2][][]*/
      {0, 0, 0, 0},
      {0, 0, 0, 0},
      {0, 1, 1, 0},
      {0, 0, 1, 1}},
     {/*[][3][][]*/
      {0, 0, 0, 0},
      {0, 0, 1, 0},
      {0, 1, 1, 0},
      {0, 1, 0, 0}}}};

/**************************************************
 * char field[HEIGHT][WIDTH];
 * 테트리스의 메인 게임 화면
 * field의 정보가 저장되는 변수
 * 초기 상태: 전부 0으로 초기화
 **************************************************/
char field[HEIGHT][WIDTH];

/**************************************************
 * int nextBlock[BLOCK_NUM];
 * 현재 블록의 shape ID와 다음 블록의 shape ID를 저장
 * nextBlock[0]: 현재 블록의 shape ID
 * nextBlock[1]: 다음 블록의 shape ID
 * rand()함수 사용: [0 ~ 6] 사이의 random한 정수값
 **************************************************/
int nextBlock[BLOCK_NUM];

/**************************************************
 * int blockRotate,blockY,blockX;
 * blockRotate: 현재 블록의 회전 횟수, 0으로 초기화
 * blockY: 현재 블록의 y 좌표, 초기값: -1
 * blockX: 현재 블록의 x 좌표, 초기값: (WIDTH / 2) - 2
 * 		     블록이 화면 중앙에 나타나도록 설정
 **************************************************/
int blockRotate, blockY, blockX;

/**************************************************
 * int score;
 * 현재 점수를 저장하는 변수
 * 초기값: 0
 **************************************************/
int score;
int score_number;
/**************************************************
 * int gameOver;
 * 게임 종료 여부를 저장
 * 초기 값: 0 (게임 진행 중)
 * 게임 종료 시: 1로 설정
 **************************************************/
int gameOver = 0;

/**************************************************
 * int timed_out;
 * 현재 블록이 매초마다 한 칸씩 내려가도록 하기 위해 사용
 * 초기 값: 0
 **************************************************/
int timed_out;

// 추천 블럭 배치 정보. 차례대로 회전, Y 좌표, X 좌표
int recommendR, recommendY, recommendX;  

/***********************************************************
 *	테트리스의 모든 global 변수를 초기화 해준다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void InitTetris();

/***********************************************************
 *	테트리스의 모든 interface를 그려준다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void DrawOutline();

/***********************************************************
 *	테트리스와 관련된 키입력을 받는다.
 *	input	:   none
 *	return	: (int) 입력받은 command
 *		  KEY_DOWN : 방향키 아래
 *		  KEY_UP   : 방향키 위
 *		  KEY_RIGHT: 방향키 오른쪽
 *		  KEY_LEFT : 방향키 왼쪽
 *		  ' '	     : Space bar
 *		  'q'/'Q'  : quit
 ***********************************************************/
int GetCommand();

/***********************************************************
 *	GetCommand로 입력받은 command에 대한 동작을 수행한다.
 *	input	: (int) GetCommand로 받은 command
 *	return	: (int) quit에 대한 입력을 받을 경우 0,
 * 		  그외의 경우 1을 return한다.
 ***********************************************************/
int ProcessCommand(int command);

/***********************************************************
 *	블럭이 일정 시간(1초)마다 내려가도록 호출되는 함수
 *	더이상 내릴 수 없을 경우,
 *		블럭을 field에 합친다.
 *		완전이 채워진 line을 지운다.
 *		next block을 current block으로 바꿔주고
 *		block의 좌표를 초기화 한다.
 *		다음 블럭을 화면에 그리고 갱신된 score를
 *		화면에 display한다.
 *	input 	: (int) sig
 *	return	: none
 ***********************************************************/
void BlockDown(int sig);

/***********************************************************
 * int CheckToMove(...);	
 * 현재 블록이 해당 위치로 이동할 수 있는지 체크하는 변수
 * input:  (char[][]) 블럭의 움직임을 확인할 필드
 *		  	 (int) 현재 블럭의 모양 ID
 *		  	 (int) 블럭의 회전 횟수
 *		  	 (int) 블럭의 Y좌표
 *		  	 (int) 블럭의 X좌표
 * return: (int) 입력에 대한 블럭 움직임이 가능하면 1
 *		           가능하지 않으면 0을 return
 ***********************************************************/
int CheckToMove(char f[HEIGHT][WIDTH], int currentBlock, int blockRotate,
                int blockY, int blockX);

/***********************************************************
 *	테트리스에서 command에 의해 바뀐 부분만 다시 그려준다.
 *	input	: (char[][]) command의해 바뀐 블럭을 확인할 필드
 *		      (int) 바뀌기 전 모양을 알기 위해 command를 입력으로 받는다.
 *		      (int) 현재 블럭의 모양 ID
 *		      (int) 블럭의 회전 횟수
 *		      (int) 블럭의 Y좌표
 *		      (int) 블럭의 X좌표
 *	return	: none
 ***********************************************************/
void DrawChange(char f[HEIGHT][WIDTH], int command, int currentBlock,
                int blockRotate, int blockY, int blockX);

/***********************************************************
 *	테트리스의 블럭이 쌓이는 field를 그려준다.
 *	input	: none
 *	return	: none
 ***********************************************************/
void DrawField();

/***********************************************************
 *	떨어지는 블럭을 field에 더해준다.
 *	input	: (char[][]) 블럭을 쌓을 필드
 *		      (int) 현재 블럭의 모양 ID
 *		      (int) 블럭의 회전 횟수
 *		      (int) 블럭의 Y좌표
 *		      (int) 블럭의 X좌표
 *	return	: none
 ***********************************************************/
int AddBlockToField(char f[HEIGHT][WIDTH], int currentBlock, int blockRotate,
                     int blockY, int blockX);

/***********************************************************
 *	완전히 채워진 Line을 삭제하고 점수를 매겨준다.
 *	input	: (char[][]) 완전히 채워진 line을 확인할 필드
 *	return	: (int) 삭제된 라인의 갯수에 대한 점수
 ***********************************************************/
int DeleteLine(char f[HEIGHT][WIDTH]);

/***********************************************************
 *	커서의 위치를 입력된 x, y의 위치로 옮겨주는 역할을 한다.
 *	input	: (int) 커서의 이동할 y 좌표
 *		      (int) 커서의 이동할 x 좌표
 *	return	: none
 ***********************************************************/
void gotoyx(int y, int x);

/***********************************************************
 *	테트리스의 화면 오른쪽상단에 다음 나올 블럭을 그려준다..
 *	input	: (int*) 블럭의 모양에 대한 ID 배열
 *	return	: none
 ***********************************************************/
void DrawNextBlock(int* nextBlock);

/***********************************************************
 *	테트리스의 화면 오른쪽 하단에 Score를 출력한다.
 *	input	: (int) 출력할 점수
 *	return	: none
 ***********************************************************/
void PrintScore(int score);

/***********************************************************
 *	해당 좌표(y,x)에 원하는 크기(height,width)의 box를 그린다.
 *	input	: (int) 그리고자 하는 박스의 왼쪽 상단모서리의 y 좌표
 *		      (int) 왼쪽 상단 모서리의 x 좌표
 *		      (int) 박스의 높이
 *		      (int) 박스의 넓이
 *	return	: none
 ***********************************************************/
void DrawBox(int y, int x, int height, int width);

/***********************************************************
 *	해당 좌표(y,x)에 원하는 모양의 블록을 그린다.
 *	input	: (int) 그리고자 하는 박스의 왼쪽 상단모서리의 y 좌표
 *		      (int) 왼쪽 상단 모서리의 x 좌표
 *		      (int) 블록의 모양
 *		      (int) 블록의 회전 횟수
 *		      (char) 블록을 그릴 패턴 모양
 *	return	: none
 ***********************************************************/
void DrawBlock(int y, int x, int blockID, int blockRotate, char tile);

/***********************************************************
 *	블록이 떨어질 위치를 미리 보여준다.
 *	input	: (int) 그림자를 보여줄 블록의 왼쪽 상단모서리의 y 좌표
 *		      (int) 왼쪽 상단 모서리의 x 좌표
 *		      (int) 블록의 모양
 *		      (int) 블록의 회전 횟수
 *	return	: none
 ***********************************************************/
void DrawShadow(int y, int x, int blockID, int blockRotate);

/****************************************************
 * drawRecommend();
 * 설명     :  추천 블럭 배치를 화면에 그린다.
 *
 * input   :  (int) 추천 블럭의 왼쪽 상단모서리의 y 좌표
 *            (int) 왼쪽 상단 모서리의 x 좌표
 *            (int) 블록의 모양
 *            (int) 블록의 회전 횟수
 ****************************************************/
void DrawRecommend(int y, int x, int blockID, int blockRotate);

/***********************************************************
 *	블록 그리기 관련 두 가지 함수를 호출한다.
 *	input	  : (int) 블록의 왼쪽 상단모서리의 y 좌표
 *		        (int) 왼쪽 상단 모서리의 x 좌표
 *		        (int) 블록의 모양
 *		        (int) 블록의 회전 횟수
 *	return	: none
 ***********************************************************/
void DrawBlockWithFeatures(int y, int x, int blockID, int blockRotate);

/***********************************************************
 *	play();
 *  설명     : 테트리스 게임을 시작한다.
 *	input 	: none
 *	return	: none
 ***********************************************************/
void play();

/***********************************************************
 *	menu();
 *  설명     : 메뉴를 보여준다.
 *	input  	: none
 *	return	: 사용자가 입력한 메뉴 번호
 ***********************************************************/
char menu();

/***********************************************************
 *	createRankList();
 *  설명     : rank.txt로부터 랭킹 정보를 읽어와 랭킹 목록을 구성한다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void createRankList();

/***********************************************************
 *	rank();
 *  설명     : 화면에 랭킹 기록들을 보여준다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void rank();

/***********************************************************
 *	writeRankFile();
 *  설명     : rank file을 생성한다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void writeRankFile();

/***********************************************************
 *	newRank();
 *  설명     : 새로운 랭킹 정보를 추가한다.
 *	input	  : (int) 새로운 랭킹의 점수
 *	return	: none
 ***********************************************************/
void newRank(int score);

/***********************************************************
 *	recommend();
 *	설명      : 추천 블럭 배치를 구한다.
 *	input	   : (RecNode*) 추천 트리의 루트
 *	return	 : (int) 추천 블럭 배치를 따를 때 얻어지는 예상 스코어
 ***********************************************************/
int recommend(RecNode* root);

/***********************************************************
 *	recommendedPlay();
 *  설명     : 추천 기능에 따라 블럭을 배치하여 진행하는 게임을 시작한다.
 *	input	  : none
 *	return	: none
 ***********************************************************/
void recommendedPlay();

/***********************************************************
 *	insertNode();
 *	설명     : 연결리스트에 새로운 노드를 삽입한다.
 *	input	  : (Node**) 연결리스트의 헤드 이중 포인터
 *            (Node*) 새로 삽입할 노드
 *	return	:  none
 ***********************************************************/
void insertNode(Node** ref_head, Node* newNode);

/* 3주차 실습 내가 만든 함수 */
void freeRecNodes(RecNode* root);
int evaluateField(char f[HEIGHT][WIDTH]);
int modified_recommend(RecNode* root);
int compareRecNodes(const void* a, const void* b);
#endif
